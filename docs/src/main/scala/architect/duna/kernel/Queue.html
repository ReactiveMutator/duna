<!DOCTYPE html>

<html>
<head>
  <title>Queue.scala</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Queue.scala</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h3 id="non-blocking-single-producer-multiple-consumers-queue-">Non blocking single producer multiple consumers queue.</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">package</span> architect
  <span class="hljs-keyword">package</span> duna
  <span class="hljs-keyword">package</span> kernel

  <span class="hljs-keyword">import</span> java.lang.<span class="hljs-type">Throwable</span>
  <span class="hljs-keyword">import</span> scala.util.{ <span class="hljs-type">Either</span>, <span class="hljs-type">Left</span>, <span class="hljs-type">Right</span> }
  <span class="hljs-keyword">import</span> scala.runtime.<span class="hljs-type">ScalaRunTime</span>._
  <span class="hljs-keyword">import</span> scala.reflect.<span class="hljs-type">ClassTag</span> 
  <span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">ConcurrentLinkedQueue</span>
  <span class="hljs-keyword">import</span> scala.collection.immutable.<span class="hljs-type">SortedMap</span>
  
  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">QueueIssue</span></span>{
    <span class="hljs-keyword">val</span> message: <span class="hljs-type">String</span>
  }

  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CantDequeueEmptyQueue</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">QueueIssue</span></span>{
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> message: <span class="hljs-type">String</span> = <span class="hljs-string">"Can't dequeue for an empty queue."</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The queue is actually a circular buffer, including two pointers, which point to the next written element and the next readable element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>[@specialized(<span class="hljs-type">Short</span>, <span class="hljs-type">Char</span>, <span class="hljs-type">Int</span>, <span class="hljs-type">Float</span>, <span class="hljs-type">Long</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">AnyRef</span>) <span class="hljs-type">A</span>: <span class="hljs-type">ClassTag</span>](<span class="hljs-params">private val size: <span class="hljs-type">Int</span></span>)</span>{self =&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Both pointers start from the zero element. They have <a href="http://tutorials.jenkov.com/java-concurrency/volatile.html">@volatile</a> annotation, because we need every thread to have an access to the newest value of the variable.
Here is the write pointer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-meta">@volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> writePointer: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>And the read pointer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-meta">@volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> readPointer: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We calculate an array size available on the machine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> availableSize = {
      <span class="hljs-keyword">val</span> runtime = <span class="hljs-type">Runtime</span>.getRuntime()</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Hard coded values are: 32bits is Int size, 4 - memory share
TODO: change integer zite to A size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (runtime.freeMemory/<span class="hljs-number">4</span>/<span class="hljs-number">32</span>).toInt <span class="hljs-comment">// 32bits is Int size, 4 - memory share</span>
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>We check the input size. If it is less than one, we make 100000 array (because I want so).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">val</span> actualSize = size <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> number <span class="hljs-keyword">if</span>(number &lt; <span class="hljs-number">1</span>) =&gt; <span class="hljs-number">100000</span>
      <span class="hljs-keyword">case</span> number <span class="hljs-keyword">if</span>(number &gt; availableSize) =&gt; availableSize
      <span class="hljs-keyword">case</span> number =&gt; number
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Then we calculate physical location of the pointers in the array buffer. It should be from 0 to actual array size. So we need to find a reminder of current pointer position and actual array size.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">physicalReadPointer</span></span>: <span class="hljs-type">Int</span> = {
      readPointer  % actualSize
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">physicalWritePointer</span></span>: <span class="hljs-type">Int</span> = {
      writePointer  % actualSize
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Here is a buffer array, where we keep all the data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> store: <span class="hljs-type">Array</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">A</span>](actualSize)</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>And the next one is for backpressure. I’ll write about it below…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> tmpStore: <span class="hljs-type">ConcurrentLinkedQueue</span>[<span class="hljs-type">A</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">ConcurrentLinkedQueue</span>[<span class="hljs-type">A</span>]()

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>: <span class="hljs-type">String</span> = {
      
      stringOf(store)

    }

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toArray</span></span>: <span class="hljs-type">Array</span>[<span class="hljs-type">A</span>] = {
      store
    }


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(function: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">Unit</span>] = {

        store.map(function) 

    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Whenever a write pointer is bigger than array size, we put next elements into the tmpStore. It is a backpressure strategy. If a producer is faster than consumer, then the default array is not enought. We start using tmpStore, which help us under heavy load. But it can cause an OutOfMemoryException exeption. Type of the tmpStore is ConcurrentLinkedQueue, so it is not limited and can be dynamically resized. Why we didn’t do it before?
Because any linked list based data structure with unknown length at runtime replaces itself with a new allocated structure when the capacity is exceeded. A new structure is allocated and a previous one is collected multiple times. This process can generate a lot of garbage and lead to memory leak.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enqueue</span></span>(value: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">QueueIssue</span>] = {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The queue is full, can’t rewrite an element which hasn’t been ridden</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span>(writePointer &gt;= actualSize){

        tmpStore.add(value)

      }<span class="hljs-keyword">else</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Enqueue a new element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        store.update(phisicalWritePointer, value) <span class="hljs-comment">// enqueue a new element</span>

      }

      <span class="hljs-keyword">val</span> newWritePointer = writePointer + <span class="hljs-number">1</span> <span class="hljs-comment">// move writePointer to the next slot</span>
      writePointer = newWritePointer

      <span class="hljs-type">Left</span>(value)

    }

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>: <span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">QueueIssue</span>] = {
      <span class="hljs-keyword">if</span>(isEmpty){ 
        
        <span class="hljs-type">Right</span>{<span class="hljs-type">CantDequeueEmptyQueue</span>()}

      }<span class="hljs-keyword">else</span>{
          <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">if</span>(readPointer &lt; actualSize || tmpStore.isEmpty){

          store(phisicalReadPointer)

        }<span class="hljs-keyword">else</span>{
          
            tmpStore.element

        
        }
        
          <span class="hljs-type">Left</span>(res)
      }
    
    }

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasNext</span></span>: <span class="hljs-type">Boolean</span> = {
      <span class="hljs-keyword">if</span>(isEmpty){ 
        
        <span class="hljs-literal">false</span>

      }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">if</span>(readPointer + <span class="hljs-number">1</span> &lt; writePointer){

            <span class="hljs-literal">true</span>
            
          }<span class="hljs-keyword">else</span>{
              
              <span class="hljs-keyword">if</span>(tmpStore.size &gt; <span class="hljs-number">2</span>){

                <span class="hljs-literal">true</span>

              } <span class="hljs-keyword">else</span>{

                <span class="hljs-literal">false</span>

              }
          }
          res
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The next method extracts next value from the queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dequeue</span></span>: <span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">QueueIssue</span>] = {

      <span class="hljs-keyword">if</span>(isEmpty){ 
        
        <span class="hljs-type">Right</span>{<span class="hljs-type">CantDequeueEmptyQueue</span>()}

      }<span class="hljs-keyword">else</span>{

        <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">if</span>(readPointer &lt; actualSize || tmpStore.isEmpty){

          <span class="hljs-keyword">val</span> value = store(phisicalReadPointer)
          value
        }<span class="hljs-keyword">else</span>{
          
          <span class="hljs-keyword">val</span> dec = tmpStore.poll

          store(phisicalReadPointer) = dec
          dec

        }
        
        <span class="hljs-keyword">val</span> newReadPointer = readPointer + <span class="hljs-number">1</span> <span class="hljs-comment">// The next pointer can point at an empty slot, will check on the next dequeue.</span>
      
        readPointer = newReadPointer
        <span class="hljs-type">Left</span>(res)
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The queue is empty or the next pointer points to an empty slot.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span></span>: <span class="hljs-type">Boolean</span> = {

        readPointer == writePointer
    }


  }</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
